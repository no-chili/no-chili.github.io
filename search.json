[{"date":"2021-08-30T03:19:28.071Z","url":"/2021/08/30/Node-%E6%96%87%E4%BB%B6/","categories":[[" ",""]],"content":"文件系统文件的操作引入const fs=require(&#39;fs&#39;) 读写操作打开：fs.open(path,flag,callback(err,fd)) 读： fs.readFile(path,&#39;utf-8&#39;,callback(err,data)) fs.read(fd,buffer,offset,length,position,callback(err,bytesRead,buffer)) 写： fs.writeFile(path,data,callback(err)) fs.write(fd,buffer,offset,length,position,callback(err,bytesWritten,buffer)) 关闭： fs.close(fd,callback(err)) 同步缓存操作 fs.fsync(fd,callback(err)) 权限操作 fs.access(path,callback(err)) 文件夹的操作获取文件目录的Stats对象： fs.stat(path,callback(err,statobj)) 创建： fs.mkdir(path,callback(err)) 读取： fs.readdir(path,callback(err,data)) 删除： fs.unlink(path,callback(err)) "},{"date":"2021-08-29T02:47:41.879Z","url":"/2021/08/29/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8/","categories":[[" ",""]],"content":"迭代器迭代器迭代器（Iterator）可以对具有（Iterable）接口的’可迭代对象’进行消费具有Iterable接口的数据类型： 字符串 数组 Map Set argument对象 NodeList等DOM集合类型 这些操作会自动调用Iterator： for…of 数组解构 扩展符操作 Array.from() new Set() new Map() Promise.all() Promise.race() yeild*操作符 迭代器内有一个next（）方法，每次成功调用都会返回一个IteratorResult对象该对象内有两个属性：done和value，分别代表是否可以再次调用next（），done：true表示’耗尽’value代表迭代对象的下一个值 只要迭代器的done为true，后续调用返回值都一样了提前终止迭代器for…of循环通过break、continue、return、throw提前退出"},{"date":"2021-08-29T01:45:35.106Z","url":"/2021/08/29/ES6-class/","categories":[[" ",""]],"content":"class写法："},{"date":"2021-08-28T10:09:03.085Z","url":"/2021/08/28/ES6-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","categories":[[" ",""]],"content":"Set和Map数据结构set特点：数据唯一没有重复的值两个属性，四个方法属性 Set.prototype.constructor 构造函数，默认Set函数 Set.prototype.size Set实例的成员总数 方法 Set.prototype.add(value) 添加某个值 Set.prototype.delete(value) 删除某个值 Set.prototype.has(value) 是否有某个值 Set.prototype.clear() 清楚所有成员 遍历 Set.keys( ) 返回键名遍历器 Set.values( ) 返回键值遍历器 由于Set没有键名或者说键名与键值永远一样，所以keys方法和values方法是一样的 Set.entries( ) 返回键值对遍历器 Set.forEach( ) 使用回调函数遍历所有成员 Set默认是可以遍历的，所以可以之间使用for…of进行遍历 Set和…搭配使用可以实现去重 数组的map和filter搭配Set（Set间接使用数组方法） 因此Set可以轻松实现交集，并集，差集 WeakSet特点：与Set类似，但是成员只能是对象三个方法 WeakSet.add( value) 添加一个新成员 WeakSet.delete( value) 清除指定成员 WeakSet.has( value) 是否有某个值 不可遍历Map特点：实现了”值-值”对应关系，相对于Object对象键的类型不限于字符串类型 Map接受任何具有Iterator接口、且每个成员都是双元素的数组的数据结构对同一个键赋值两次，后一次将覆盖前一次键是否相同是根据内存地址而定的而不是值属性和方法属性 Map.size 返回键值对的个数（成员个数） 方法 Map.set(key,value) 更新或生成新的键值 Map.get(key) 读取key对应的值，不存在该键就返回undefined Map.has(key) 是否有某个键 Map.delete(key) 删除某个键，成功返回true失败返回false Map.clear() 清除所有成员 遍历 Map.prototype.keys() 返回键名的遍历器。 Map.prototype.values() 返回键值的遍历器。 Map.prototype.entries() 返回所有成员的遍历器。 Map.prototype.forEach() 遍历 Map 的所有成员。 与…搭配使用Map结构可以用…运算符快速转成数组，且可以对键转换，值转换或者键值对转换 WeakMap特点：只接受对象为键名（null除外）WeakMap的键的引用是弱引用，外部的引用消失，WeakMap内部的引用不会阻止垃圾回收机制，WeakMap使得解决内存泄露简单了很多"},{"title":"Generator函数","date":"2021-08-27T05:36:03.000Z","url":"/2021/08/27/ES6-Generator%E5%87%BD%E6%95%B0/","categories":[[" ",""]],"content":"Generator函数（生成器）拥有函数块内暂停和恢复代码执行的能力，生成器在遇到yield关键字之前会正常执行，遇到yield后停止，函数的作用域和状态会被保留特征：1.function关键字与函数名之间有一个*号2.函数体内部使用yield表达式，定义不同的状态 调用与普通函数一样是在函数后面加圆括号，但不同的是Generator函数返回的是一个遍历器对象，指向内部状态的指针需要调用next方法再能执行一个分段，该分段从上个执行结束点开始，直到遇见下一个yield 与for（ of ）搭配使用"},{"title":"Promise","date":"2021-08-26T03:42:59.000Z","url":"/2021/08/26/ES6-Promise%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E7%82%B9/","categories":[[" ",""]],"content":"PromisePromise的一些特点 promise新建后就会立即执行 "},{"title":"async函数","date":"2021-08-26T03:42:59.000Z","url":"/2021/08/26/ES6-async%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/","categories":[[" ",""]],"content":"async函数介绍async函数其实是generator函数的语法糖，async函数就是将generator函数的*替换成async将yield替换成awaitasync函数对generator函数的改进 async内置执行器，可以像普通函数一样执行 语义更清楚 更广的适用范围，yield后面只能跟Thunk函数或者Promise对象，await后面可以跟Promise对象也可以跟原始数据类型的值（但会自动转换成resolve的Promise对象） 返回值是Promise对象，可以用then指定下一步操作 async函数完全可以看作是多个异步操作包装成的Promise对象,而await则是内部then的语法糖 语法返回的promise对象 async内部return的值会成文then的参数 内部抛出错误会导致返回的promise状态变为rejiect 内部抛出的错误还会被catch捕获 promise对象状态的改变 只有等内部所有await后面的promise执行完才会改变状态 除非遇到return或者抛出错误，async内的异步操作执行完才能执行then await命令 await后面是一个promise对象就返回该结果值 如果不是promise就直接返回对应值 定义了then方法的对象await会视为promise处理 await后面的promise变为reject状态参数会被传到async的catch 任何一个await后面的promise变为reject，async就会中断执行 如果想要继续执行可以为其单独写catch 或者放到try …catch结构里面 应用async函数结合fetch() "},{"title":"page","date":"2021-08-26T03:42:59.000Z","url":"/page/index.html","categories":[[" ",""]]},{"title":"friends","date":"2021-08-26T03:43:13.000Z","url":"/friends/index.html","categories":[[" ",""]]},{"title":"search","date":"2021-08-26T03:56:55.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2021-08-26T03:59:06.000Z","url":"/tags/index.html","categories":[[" ",""]]}]